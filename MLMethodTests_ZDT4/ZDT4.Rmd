---
title: "Pattern Recognition Method Comparison: ZDT4"
author: "Jonathan Boualavong"
output: html_notebook
---

<!-- output:    -->
<!--   md_document: -->
<!--     variant: markdown_github -->

# Description
This notebook takes the data generated by the script in /Ex_ZDT4, which describes the newly developed method, and compares it existing pattern recognition algorithms. 
This multi-objective problem was selected as a simple illustration, as it only takes 2 inputs and provides 2 outputs, but has the complication of a local minimum and maximum besides the Pareto optimum.

The pattern recognition algorithms are:
* Support Vector Machines: example supervised learning problem
* Gaussian mixture models: example unsupervised learning problem

These are compared to the process of characterizing the optimal inputs using Gaussian Processes refined by iterative sampling.
The acceptance criteria for the GP-based method and the SVM method are identical for direct comparison. 
For ease of calculation, the iterative refinement of the GP models are not included here, nor are the calculations of the conditional probabilities.
The SVM and GMM methods are tested with both the data after finding the Pareto front and the data after iterative refinement to see if the refinement step is useful for these other processes as well.

Comparison among the supervised methods is done by looking at the error rate across the entire space. 
Since the test function is a simple polynomial, the solution of what is acceptable can be found explicitly. 
For the GP method, since acceptance is defined by a probability, the error rate is weighted by the probability of acceptance. 
For the SVM method, the error rate is simply the number of incorrectly categorized points divided by the total number of test points.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Clear the workspace and define the functions.

```{r Load Packages}
# Setup
rm(list = ls())
# Visualization
library(dplyr)
library(ggplot2)
library(patchwork)
# Parallel processing
library(parallel)
library(doParallel)
# Gaussian processes
library(GPareto)
library(DiceKriging)
library(DiceOptim)
# Optimization
library(GA)
# Gaussian Mixture Models
library(mclust)
# Support Vector Machines
library(e1071)
```

Relevant functions

The functions to optimize are a modified version of the ZDT4 function from Zitzler, Deb, and Theile 2000. The frequency of the sinusoid has been modified to reduce the number of local optima for illutrative purposes.

```{r Optimization Functions}
# Input set of (x1, x2) on [0, 1]
ZDT4.mod = function (x) 
{
  if (is.null(dim(x))) {
    x <- matrix(x, nrow = 1)
  }
  n <- ncol(x)
  g <- 1 + 10 * (n - 1) + rowSums((x[, 2:n, drop = FALSE] * 
    0.5 - 0.25)^2 - 10 * cos(0.5 * pi * (x[, 2:n, drop = FALSE] * 
    10 - 5)))
  return(cbind(x[, 1], g * (1 - sqrt(x[, 1]/g))))
}

```

Normalization-related functions
```{r Functions part 2}
# Normalized objective functions
n.obj = function(GPar.data, GPar.front){
  # Given dataframes that describe the entire dataset and the front, find the normalized (x,y)
  # Objective functions are named 'f1' and 'f2'
  
  # Normalize the objective outputs so that the utopia point is (0,0) and the nadir point is (1,1)
  f1.up = GPar.front$f1[which.min(GPar.front$f2)]
  f2.up = GPar.front$f2[which.min(GPar.front$f1)]
  GPar.data$f1.norm = (GPar.data$f1 - min(GPar.front$f1))/(f1.up - min(GPar.front$f1))
  GPar.data$f2.norm = (GPar.data$f2 - min(GPar.front$f2))/(f2.up - min(GPar.front$f2))

  return(GPar.data)
}

# Calculate the normalized distance
n.dist = function(f1.norm, f2.norm, GPar.front){
  # Given the normalized coordinates (f1.norm, f2.norm) and the Pareto frontier estimate,
  # find the distance along the constant f2/f1 ratio line
  
  # Determine the two points on the Pareto front that define the relevant segment
  GPar.front$theta = atan(GPar.front$f2.norm / GPar.front$f1.norm)
  if(f1.norm < 0){f1.norm = 0}
  if(f2.norm < 0){f2.norm = 0}
  ratio = atan(f2.norm/f1.norm)
  
  # Check if the angle is the same as a point on the Pareto front
  if(any(abs(ratio - GPar.front$theta) < 1e-5)){
    pos = which.min(abs(ratio - GPar.front$theta))
    Par.x = GPar.front$f1.norm[pos]
    Par.y = GPar.front$f2.norm[pos]
  } else{ # Otherwise, two points are needed for linear interpolation
    # Break the dataframe into theta above and below
    Par.above = GPar.front[GPar.front$theta - ratio > 0,]
    Par.below = GPar.front[GPar.front$theta - ratio < 0,]
    # Find the point closest to the angle
    pos.above = which.min(abs(ratio - Par.above$theta))
    pos.below = which.min(abs(ratio - Par.below$theta))
    # Linear interpolation
    ln.x = c(Par.above$f1.norm[pos.above], Par.below$f1.norm[pos.below])
    ln.y = c(Par.above$f2.norm[pos.above], Par.below$f2.norm[pos.below])
    slp = diff(ln.y)/diff(ln.x)
    # Find the point on the segment with the same angle, ie. the same ratio.
    # Solving with this constraint has analytical solution:
    Par.x = (ln.y[1] - slp*ln.x[1]) / (f2.norm/f1.norm - slp)
    Par.y = slp*(Par.x - ln.x[1]) + ln.y[1]
  }
  
  # Linear distance to the front is the difference between distances to the origin
  dist = sqrt(f1.norm^2 + f2.norm^2) - sqrt(Par.x^2 + Par.y^2)
  return(dist)
}
```

Gaussian process parameter tuning
```{r}
fill.sample.mod = function(GPar.data, input.name, output.name){
  # Calculate the GP model to use. 
  # Using the km function, but applies checks on the system to make sure that 
  # the model uncertainty matches expectations based on GP, ie. it did not
  # fail to converge.
  
  # Based on testing, the model is bad when the 10% percentile and 90% percentile 
  # of the standard deviation are of the same order of magnitude. This is easiest
  # checked if the difference between the 10th and 90th percentile
  # is larger than the difference between the 25th and 75th.
  pt10 = 1; pt90 = 1; pt25 = 1; pt75 = 1
  while(log10(pt90/pt10) <= log10(pt75/pt25)){
    mod.out = km(design = GPar.data[, input.name], response = GPar.data[, output.name], 
                 covtyp = 'gauss', # Gaussian uncertainty
                 optim.method = 'gen', # Genetic algorithm optimization
                 control = list(trace = FALSE, # Turn off tracking to simplify output
                                pop.size = 50, # Increase robustness
                                max.generations = 400), # Some convergence issues
                 nugget = 1e-6, # Avoid eigenvalues of 0
                 )
    
    # Randomly sample 200 points from the search space
    pt = 200; i = 1
    lims = range(GPar.data[,input.name[i]])
    samp = data.frame(runif(n = pt, min = lims[1], max = lims[2]))
    for(i in 2:length(input.name)){
      lims = range(GPar.data[,input.name[i]])
      samp[,i] = runif(n = pt, min = lims[1], max = lims[2])
    }
    names(samp) = input.name
    
    # Find model output to find the percentile ranks for this iteration
    res = predict(object = mod.out, newdata = samp, type = 'UK')
    pt10 = quantile(res$sd, 0.10); pt90 = quantile(res$sd, 0.90)
    pt25 = quantile(res$sd, 0.25); pt75 = quantile(res$sd, 0.75)
  }
  return(mod.out)
}

```


## Comparison of GP-based Boundaries with Different Acceptance Criteria

Comparison of the boundaries to show how changing the acceptance criteria changes the shape of the near-Pareto set. Showcases the robustness to different selection criteria, indicating flexibility in the design objectives.

```{r GP: Comparison of Acceptance Criteria}
## Loading
# Load datasets for obtaining the refined probability functions
data.delta = read.csv('../Ex_ZDT4/GPar_Accept_Delta1.csv')
data.cutof = read.csv('../Ex_ZDT4/GPar_Accept_Threshold.csv')
data.radan = read.csv('../Ex_ZDT4/GPar_Accept_Radius.csv')
# Load datasets prior to refinement
data.paret = read.csv('../Ex_ZDT4/GPar_all_start.csv')
data.paret$rad = sqrt(data.paret$f1.norm^2 + data.paret$f2.norm^2)
# Compare to the estimate of the Pareto frontier
GPar.front = read.csv(file = '../Ex_ZDT4/GPar_fnt_start.csv')

##
# Grid of the relevant region to visualize and interpret. 
# No relevant information is gained outside of (0.4, 0.6) for x2 and x3
lower = c(0, 0, 0); upper = c(1,1, 1); grid.sz = 100
fine.grid = expand.grid(x1 = seq(from = lower[1], to = upper[1], length.out = grid.sz), 
                        x2 = seq(from = lower[2], to = upper[2], length.out = grid.sz/20+1),
                        x3 = seq(from = lower[3], to = upper[3], length.out = grid.sz/20+1))
fine.grid = fine.grid[,1:3]
names(fine.grid) = c('x1', 'x2', 'x3')

# Calculate the actual results
res = ZDT4.mod(x = as.matrix(fine.grid))
fine.grid$f1 = res[,1]; fine.grid$f2 = res[,2]
fine.grid = n.obj(GPar.data = fine.grid, GPar.front = GPar.front)
fine.grid$dist = NaN
for(row in 1:nrow(fine.grid)){
  fine.grid$dist[row] = n.dist(f1.norm = fine.grid$f1.norm[row], 
                               f2.norm = fine.grid$f2.norm[row], 
                               GPar.front = GPar.front)
}
fine.grid$ang = atan(fine.grid$f2.norm/fine.grid$f1.norm)*180/pi*10/9
fine.grid$rad = sqrt(fine.grid$f1.norm^2 + fine.grid$f2.norm^2)

##
# Normalized distance
fine.grid$delta = 0
fine.grid$delta[fine.grid$dist <= 1] = 1

mod.dist.pre = fill.sample.mod(GPar.data = data.paret, input.name = c('x1', 'x2', 'x3'), output.name = 'dist')
res = predict(object = mod.dist.pre, newdata = fine.grid[,c('x1', 'x2', 'x3')], type = "UK")
fine.grid$prob.delta.pre = pnorm(q = 0, mean = res$mean - 1, sd = res$sd)

mod.dist.post = fill.sample.mod(GPar.data = data.delta, input.name = c('x1', 'x2', 'x3'), output.name = 'dist')
res = predict(object = mod.dist.post, newdata = fine.grid[,c('x1', 'x2', 'x3')], type = "UK")
fine.grid$prob.delta.post = pnorm(q = 0, mean = res$mean - 1, sd = res$sd)

##
# Threshold cutoff
fine.grid$cutof = 0
fine.grid$cutof[fine.grid$f1.norm <= 1 & fine.grid$f2.norm <= 1] = 1

mod.f1.pre = fill.sample.mod(GPar.data = data.paret, input.name = c('x1', 'x2', 'x3'), output.name = 'f1.norm')
mod.f2.pre = fill.sample.mod(GPar.data = data.paret, input.name = c('x1', 'x2', 'x3'), output.name = 'f2.norm')
res1 = predict(object = mod.f1.pre, newdata = data.frame(x1 = fine.grid$x1, 
                        x2 = fine.grid$x2, x3 = fine.grid$x3), type = "UK")
res2 = predict(object = mod.f2.pre, newdata = data.frame(x1 = fine.grid$x1, 
                        x2 = fine.grid$x2, x3 = fine.grid$x3), type = "UK")
fine.grid$prob.cutof.pre = pnorm(q = 0, mean = res1$mean - 1, sd = res1$sd) * 
  pnorm(q = 0, mean = res2$mean - 1, sd = res2$sd)

mod.f1.post = fill.sample.mod(GPar.data = data.cutof, input.name = c('x1', 'x2', 'x3'), output.name = 'f1.norm')
mod.f2.post = fill.sample.mod(GPar.data = data.cutof, input.name = c('x1', 'x2', 'x3'), output.name = 'f2.norm')
res1 = predict(object = mod.f1.post, newdata = data.frame(x1 = fine.grid$x1, 
                        x2 = fine.grid$x2, x3 = fine.grid$x3), type = "UK")
res2 = predict(object = mod.f2.post, newdata = data.frame(x1 = fine.grid$x1, 
                        x2 = fine.grid$x2, x3 = fine.grid$x3), type = "UK")
fine.grid$prob.cutof.post = pnorm(q = 0, mean = res1$mean - 1, sd = res1$sd) * 
  pnorm(q = 0, mean = res2$mean - 1, sd = res2$sd)

##
# Radius-angle
fine.grid$radan = 0
fine.grid$radan[fine.grid$rad <= 1 & fine.grid$ang > 20] = 1

mod.rad.pre = fill.sample.mod(GPar.data = data.paret, input.name = c('x1', 'x2', 'x3'), output.name = 'rad')
mod.ang.pre = fill.sample.mod(GPar.data = data.paret, input.name = c('x1', 'x2', 'x3'), output.name = 'theta')
res1 = predict(object = mod.rad.pre, newdata = data.frame(x1 = fine.grid$x1, 
                        x2 = fine.grid$x2, x3 = fine.grid$x3), type = "UK")
res2 = predict(object = mod.ang.pre, newdata = data.frame(x1 = fine.grid$x1, 
                        x2 = fine.grid$x2, x3 = fine.grid$x3), type = "UK")
fine.grid$prob.radan.pre = pnorm(q = 0, mean = res1$mean - 1, sd = res1$sd) * 
  (1 - pnorm(q = 0, mean = res2$mean - 20, sd = res2$sd))

mod.rad.post = fill.sample.mod(GPar.data = data.radan, input.name = c('x1', 'x2', 'x3'), output.name = 'rad')
mod.ang.post = fill.sample.mod(GPar.data = data.radan, input.name = c('x1', 'x2', 'x3'), output.name = 'theta')
res1 = predict(object = mod.rad.post, newdata = data.frame(x1 = fine.grid$x1, 
                        x2 = fine.grid$x2, x3 = fine.grid$x3), type = "UK")
res2 = predict(object = mod.ang.post, newdata = data.frame(x1 = fine.grid$x1, 
                        x2 = fine.grid$x2, x3 = fine.grid$x3), type = "UK")
fine.grid$prob.radan.post = pnorm(q = 0, mean = res1$mean - 1, sd = res1$sd) * 
  (1 - pnorm(q = 0, mean = res2$mean - 20, sd = res2$sd))

```

The error rate in the GP model estimate should account for the built-in uncertainty in the model. 
The probability that the model gives the wrong result given the (x1, x2, x3) coordinates is the probability that it accepts the point when it should reject it, or vice versa.
Since all (x1, x2, x3) are equally likely in this mathematical function, the error rate of the GP model is the average of these probabilities.
There should be an evident decrease in the error rate between the pre- and post-refinement models.

The uncertainty in the error rate is sqrt(p*(1-p)/N) because it is simply a frequency.

Since there are 3 inputs to the function, a fine-spaced grid will require too much memory with little reward to accuracy. A coarse, 4-level grid will be used to ensure some sampling throughout the space, as well as 10^3 randomly sampled points.

```{r GP: Error rate functions}
error.test.samp = function(nlevel, nsamp){
  # Generates the samples for determining the error of the model
  # 3 dimensional input, each with a domain of (0.1)
  
  # Initial grid:
  grid.sample = expand.grid(x1 = seq(from = 0, to = 1, length.out = nlevel),
             x2 = seq(from = 0, to = 1, length.out = nlevel),
             x3 = seq(from = 0, to = 1, length.out = nlevel))
  grid.sample = grid.sample[,1:3]
  names(grid.sample) = c('x1', 'x2', 'x3')
  rand.sample = data.frame(x1 = runif(n = nsamp, min = 0, max = 1),
                           x2 = runif(n = nsamp, min = 0, max = 1),
                           x3 = runif(n = nsamp, min = 0, max = 1))
  return(rbind(grid.sample, rand.sample))
}

# Function to calculate the sample set
error.test.eval = function(nlevel, nsamp){
  err.samp = error.test.samp(nlevel = nlevel, nsamp = nsamp)
  
  # Evaluate the function
  res = ZDT4.mod(x = as.matrix(err.samp))
  err.samp$f1 = res[,1]; err.samp$f2 = res[,2]
  # Normalized evaluation
  err.samp = n.obj(GPar.data = err.samp, GPar.front = GPar.front)
  # Pareto distance
  err.samp$dist = NaN
  for(row in 1:nrow(err.samp)){
    err.samp$dist[row] = n.dist(f1.norm = err.samp$f1.norm[row], 
                                f2.norm = err.samp$f2.norm[row], 
                                GPar.front = GPar.front)
  }
  
  # Utopia radius, f1 prioritization
  err.samp$ang = atan(err.samp$f2.norm/err.samp$f1.norm)*180/pi*10/9
  err.samp$rad = sqrt(err.samp$f1.norm^2 + err.samp$f2.norm^2)
  return(err.samp)
}

# Calculate all errors: minimizes the number of times functions are evaluated
error.test.screen = function(mod.dist, mod.f1, mod.f2, mod.rad, mod.ang, nsamp, nlevel){
  # Obtain sample
  err.samp = error.test.eval(nlevel = nlevel, nsamp = nsamp)
  # Accepted points
  err.samp$delta = 0; err.samp$delta[err.samp$dist < 1] = 1
  err.samp$cutof = 0; 
  err.samp$cutof[err.samp$f1.norm < 1 & err.samp$f2.norm < 1] = 1
  err.samp$radan = 0; 
  err.samp$radan[err.samp$rad < 1 & err.samp$ang > 20] = 1
  
  ## Model estimate: Delta from the pareto front
  res = predict(object = mod.dist, newdata = err.samp[,c('x1', 'x2', 'x3')], type = 'UK')
  # Probability of acceptance
  p.acc = pnorm(q = 0, mean = res$mean - 1, sd = res$sd)
  # Probability of correct result
  p.err = p.acc
  p.err[err.samp$delta == 1] = 1 - p.err[err.samp$delta == 1]
  # Average error rate
  err.rate = mean(p.err)
  # Uncertainty in the error rate = sqrt(p*(1-p)/N)
  # err.rate.err = sqrt(err.rate*(1-err.rate)/nrow(err.samp))
  # Uncertainty as a quantile: 0.025-0.975
  err.rate.err = unname(quantile(x = err.rate, prob = c(0.025, 0.975)))
  # Store
  delta = c(err.rate, err.rate.err) 
  
  ## Model estimate: normalized cutoff
  res1 = predict(object = mod.f1, newdata = err.samp[,c('x1', 'x2', 'x3')], type = 'UK')
  res2 = predict(object = mod.f2, newdata = err.samp[,c('x1', 'x2', 'x3')], type = 'UK')
  # Probability of acceptance
  p.acc = pnorm(q = 0, mean = res1$mean - 1, sd = res1$sd)*
    pnorm(q = 0, mean = res2$mean - 1, sd = res2$sd)
  # Probability of correct result
  p.err = p.acc
  p.err[err.samp$cutof == 1] = 1 - p.err[err.samp$cutof == 1]
  # Average error rate
  err.rate = mean(p.err)
  # Uncertainty in the error rate = sqrt(p*(1-p)/N)
  # err.rate.err = sqrt(err.rate*(1-err.rate)/nrow(err.samp))
  err.rate.err = unname(quantile(x = err.rate, prob = c(0.025, 0.975)))
  # Store
  cutof = c(err.rate, err.rate.err) 
  
  # Model estimate
  res1 = predict(object = mod.rad, newdata = err.samp[,c('x1', 'x2', 'x3')], type = 'UK')
  res2 = predict(object = mod.ang, newdata = err.samp[,c('x1', 'x2', 'x3')], type = 'UK')
  # Probability of acceptance
  p.acc = pnorm(q = 0, mean = res1$mean - 1, sd = res1$sd)*
    (1-pnorm(q = 0, mean = res2$mean - 20, sd = res2$sd))
  # Probability of correct result
  p.err = p.acc
  p.err[err.samp$radan == 1] = 1 - p.err[err.samp$radan == 1]
  # Average error rate
  err.rate = mean(p.err)
  # Uncertainty in the error rate = sqrt(p*(1-p)/N)
  # err.rate.err = sqrt(err.rate*(1-err.rate)/nrow(err.samp))
  err.rate.err = unname(quantile(x = err.rate, prob = c(0.025, 0.975)))
  # Store
  radan = c(err.rate, err.rate.err)
  
  return(c(delta, cutof, radan))
}

```

```{r GP: Error Rate Calculation}
GP.pre = error.test.screen(mod.dist = mod.dist.pre, mod.f1 = mod.f1.pre, 
                           mod.f2 = mod.f2.pre, mod.rad = mod.rad.pre, 
                           mod.ang = mod.ang.pre, nsamp = 5e4, nlevel = 5)
GP.post = error.test.screen(mod.dist = mod.dist.post, mod.f1 = mod.f1.post, 
                           mod.f2 = mod.f2.post, mod.rad = mod.rad.post, 
                           mod.ang = mod.ang.post, nsamp = 5e4, nlevel = 5)

```

```{r GP: Error Rate Visuaized}
error.rate = data.frame(rate = c(GP.pre[c(TRUE, FALSE, FALSE)], GP.post[c(TRUE, FALSE, FALSE)]), 
                        err.lo = c(GP.pre[c(FALSE, TRUE, FALSE)], GP.post[c(FALSE, TRUE, FALSE)]),
                        err.hi = c(GP.pre[c(FALSE, FALSE, TRUE)], GP.post[c(FALSE, FALSE, TRUE)]),
                 method = 'GP', source = c(rep('0pre', 3), rep('1post', 3)),
                 criteria = rep(c('Pareto Distance', 'Objective Cutoff', 
                              'Distance + Priority')))
ggplot(error.rate) + 
  geom_col(mapping = aes(x = source, y = rate, fill = source)) +
  geom_errorbar(mapping = aes(x = source, y = rate, ymin = err.lo, ymax = err.hi), width = 0.5) +
  facet_wrap(~criteria, scales = 'free') +
  scale_x_discrete(breaks = c(), labels = c()) +
  labs(x = '', y = 'Error Probability') +
  scale_fill_discrete(labels = c('0pre' = 'Before', '1post' = 'After'), name = '') +
  theme_classic() + scale_y_continuous(expand = c(0.01,0))

```

In 3 dimensions, it is difficult to compare the calculated and true boundary edges without prohibitively fine resolution calculations. Instead, the primary accuracy measure is the probability that the model incorrectly categorizes a point as sub-optimal based on the defined criteria. These probabilities are incredibly small, likely due to the fact that optimal points are rare events. Of the 3 criteria, 2 showed a slight improvement in accuracy due to additional points being included in the training data. It is possible that the additional data biased the results in such a way to minimize the importance of the local minima, instead smoothing over it instead.

------------

# Existing Method: Support Vector Machines
The method should use only the data from the initial Pareto front calculation. 
Additional samples may be necessary to refine the results, but there is no established method for this refinement as of yet.

SVM methods require existing labels for the points; in this case, the labels are whether or not the point meets the same three selection criteria as tested with the new GP method.

```{r SVM: Functions}
SVM.mod.all = function(input.data){
  # Given input data, find all 4 default models and return as a list
  fit.rad = svm(as.factor(cat) ~ x1*x2*x3, data = input.data[,c('x1', 'x2', 'x3', 'cat')], 
            scale = FALSE, kernel = "radial", cost = 5)
  fit.lin = svm(as.factor(cat) ~ x1*x2*x3, data = input.data[,c('x1', 'x2', 'x3', 'cat')], 
            scale = FALSE, kernel = "linear", cost = 5)
  fit.pol = svm(as.factor(cat) ~ x1*x2*x3, data = input.data[,c('x1', 'x2', 'x3', 'cat')], 
            scale = FALSE, kernel = "polynomial", cost = 5)
  fit.sig = svm(as.factor(cat) ~ x1*x2*x3, data = input.data[,c('x1', 'x2', 'x3', 'cat')], 
            scale = FALSE, kernel = "sigmoid", cost = 5)
  return(list(rad = fit.rad, lin = fit.lin, pol = fit.pol, sig = fit.sig))
}

SVM.err = function(nsamp, mod.list, nlevel = 5){
  # Obtain sample of actual results
  err.samp = error.test.eval(nlevel = nlevel, nsamp = nsamp)
  # Accepted points
  err.samp$delta = 0; err.samp$delta[err.samp$dist < 1] = 1
  err.samp$cutof = 0; 
  err.samp$cutof[err.samp$f1.norm < 1 & err.samp$f2.norm < 1] = 1
  err.samp$radan = 0; 
  err.samp$radan[err.samp$rad < 1 & err.samp$ang > 20] = 1
  
  ## Model estimates: delta from Pareto front
  err.samp$rad = predict(object = mod.list$rad.delta, newdata = err.samp[,c('x1', 'x2', 'x3')])
  err.samp$lin = predict(object = mod.list$lin.delta, newdata = err.samp[,c('x1', 'x2', 'x3')])
  err.samp$pol = predict(object = mod.list$pol.delta, newdata = err.samp[,c('x1', 'x2', 'x3')])
  err.samp$sig = predict(object = mod.list$sig.delta, newdata = err.samp[,c('x1', 'x2', 'x3')])
  # Error rate
  err.rate = c(nrow(filter(err.samp, rad == 1 & delta == 0)) + nrow(filter(err.samp, rad == 0 & delta == 1)),
               nrow(filter(err.samp, lin == 1 & delta == 0)) + nrow(filter(err.samp, lin == 0 & delta == 1)),
               nrow(filter(err.samp, pol == 1 & delta == 0)) + nrow(filter(err.samp, pol == 0 & delta == 1)),
               nrow(filter(err.samp, sig == 1 & delta == 0)) + nrow(filter(err.samp, sig == 0 & delta == 1)))
  err.rate = err.rate/nrow(err.samp)
  err.rate.err = sqrt(err.rate*(1-err.rate)/nrow(err.samp))
  delta = c(err.rate, err.rate.err)

  ## Model estimates: normalized cutoff
  err.samp$rad = predict(object = mod.list$rad.cutof, newdata = err.samp[,c('x1', 'x2', 'x3')])
  err.samp$lin = predict(object = mod.list$lin.cutof, newdata = err.samp[,c('x1', 'x2', 'x3')])
  err.samp$pol = predict(object = mod.list$pol.cutof, newdata = err.samp[,c('x1', 'x2', 'x3')])
  err.samp$sig = predict(object = mod.list$sig.cutof, newdata = err.samp[,c('x1', 'x2', 'x3')])
  # Error rate
  err.rate = c(nrow(filter(err.samp, rad == 1 & cutof == 0)) + nrow(filter(err.samp, rad == 0 & cutof == 1)),
               nrow(filter(err.samp, lin == 1 & cutof == 0)) + nrow(filter(err.samp, lin == 0 & cutof == 1)),
               nrow(filter(err.samp, pol == 1 & cutof == 0)) + nrow(filter(err.samp, pol == 0 & cutof == 1)),
               nrow(filter(err.samp, sig == 1 & cutof == 0)) + nrow(filter(err.samp, sig == 0 & cutof == 1)))
  err.rate = err.rate/nrow(err.samp)
  err.rate.err = sqrt(err.rate*(1-err.rate)/nrow(err.samp))
  cutof = c(err.rate, err.rate.err)
  
  ## Model estimates: normalized cutoff
  err.samp$rad = predict(object = mod.list$rad.radan, newdata = err.samp[,c('x1', 'x2', 'x3')])
  err.samp$lin = predict(object = mod.list$lin.radan, newdata = err.samp[,c('x1', 'x2', 'x3')])
  err.samp$pol = predict(object = mod.list$pol.radan, newdata = err.samp[,c('x1', 'x2', 'x3')])
  err.samp$sig = predict(object = mod.list$sig.radan, newdata = err.samp[,c('x1', 'x2', 'x3')])
  # Error rate
  err.rate = c(nrow(filter(err.samp, rad == 1 & radan == 0)) + nrow(filter(err.samp, rad == 0 & radan == 1)),
               nrow(filter(err.samp, lin == 1 & radan == 0)) + nrow(filter(err.samp, lin == 0 & radan == 1)),
               nrow(filter(err.samp, pol == 1 & radan == 0)) + nrow(filter(err.samp, pol == 0 & radan == 1)),
               nrow(filter(err.samp, sig == 1 & radan == 0)) + nrow(filter(err.samp, sig == 0 & radan == 1)))
  err.rate = err.rate/nrow(err.samp)
  err.rate.err = sqrt(err.rate*(1-err.rate)/nrow(err.samp))
  radan = c(err.rate, err.rate.err)

  return(c(delta, cutof, radan))
}
# SVM.err(nsamp = 500, mod.list = mod.list.pre, nlevel = 5)

```

```{r SVM: Errors}
data.start = read.csv(file = 'GPar_all_start.csv')
data.delta = read.csv('GPar_Accept_Delta1.csv')
data.cutof = read.csv('GPar_Accept_Threshold.csv')
data.radan = read.csv('GPar_Accept_Radius.csv')

# Define acceptance: distance
data.start$cat = 0; data.delta$cat = 0
data.start$cat[data.start$dist <= 1] = 1
data.delta$cat[data.delta$dist <= 1] = 1
mod.delta.pre = SVM.mod.all(input.data = data.start)
mod.delta.post = SVM.mod.all(input.data = data.delta)

# Define acceptance: Cutoff
data.start$cat = 0; data.cutof$cat = 0
data.start$cat[data.start$f1.norm <= 1 & data.start$f2.norm <= 1] = 1
data.cutof$cat[data.cutof$f1.norm <= 1 & data.cutof$f2.norm <= 1] = 1
mod.cutof.pre = SVM.mod.all(input.data = data.start)
mod.cutof.post = SVM.mod.all(input.data = data.cutof)

# Define acceptance: utopia distance and priority
data.start$cat = 0; data.radan$cat = 0
data.start$cat[sqrt(data.start$f1.norm^2 + data.start$f2.norm^2) <= 1 & data.start$theta > 20] = 1
data.radan$cat[sqrt(data.radan$f1.norm^2 + data.radan$f2.norm^2) <= 1 & data.radan$theta > 20] = 1
mod.radan.pre = SVM.mod.all(input.data = data.start)
mod.radan.post = SVM.mod.all(input.data = data.radan)

# Rename to combine
names(mod.delta.pre) = paste(names(mod.delta.pre), '.delta', sep = '')
names(mod.radan.pre) = paste(names(mod.radan.pre), '.radan', sep = '')
names(mod.cutof.pre) = paste(names(mod.cutof.pre), '.cutof', sep = '')
mod.list.pre = append(mod.delta.pre, mod.radan.pre)
mod.list.pre = append(mod.list.pre, mod.cutof.pre)
names(mod.delta.post) = paste(names(mod.delta.post), '.delta', sep = '')
names(mod.radan.post) = paste(names(mod.radan.post), '.radan', sep = '')
names(mod.cutof.post) = paste(names(mod.cutof.post), '.cutof', sep = '')
mod.list.post = append(mod.delta.post, mod.radan.post)
mod.list.post = append(mod.list.post, mod.cutof.post)

# Calculate errors
err.pre = SVM.err(nsamp = 5e4, mod.list = mod.list.pre, nlevel = 5)
err.post = SVM.err(nsamp = 5e4, mod.list = mod.list.post, nlevel = 5)

# Combine for storage
err.SVM = data.frame(rate = c(err.pre[c(rep(TRUE, 4), rep(FALSE, 4))], 
                              err.post[c(rep(TRUE, 4), rep(FALSE, 4))]),
                     err.lo = c(err.pre[c(rep(FALSE, 4), rep(TRUE, 4))], 
                              err.post[c(rep(FALSE, 4), rep(TRUE, 4))]),
                     method = c('SVM-rad', 'SVM-lin', 'SVM-pol', 'SVM-sig'), 
                     source = c(rep('0pre', 12), rep('1post', 12)),
                     criteria = c(rep('Pareto Distance', 4), rep('Objective Cutoff', 4), 
                              rep('Distance + Priority', 4)))
# Re-calculate uncertainty as 95% confidence bound
err.SVM$err.hi = err.SVM$rate + err.SVM$err.lo*1.96
err.SVM$err.lo = err.SVM$rate - err.SVM$err.lo*1.96
```

```{r}
ggplot(rbind(error.rate, err.SVM)) +
  geom_col(mapping = aes(x = source, y = rate, fill = source)) +
  geom_errorbar(mapping = aes(x = source, y = rate, ymin = err.lo, ymax = err.hi), color = 'black', width = 0.5) +
  facet_grid(criteria~method) +
  labs(x = '', y = 'Error Probability', fill = '') + scale_x_discrete(breaks = c()) +
  scale_fill_discrete(breaks = c('0pre', '1post'), labels = c('0pre' = 'Before', '1post' = 'After'))

```

Predictions of all SVM are identical - should they be? Test with fine grid

```{r}
# Set up grid
lower = c(0, 0, 0); upper = c(1, 1, 1); grid.sz = 75
fine.grid = expand.grid(x1 = seq(from = lower[1], to = upper[1], length.out = grid.sz), 
                        x2 = seq(from = lower[2], to = upper[2], length.out = grid.sz),
                        # x3 = seq(from = lower[3], to = upper[3], length.out = 9))
                        x3 = 0.5)
fine.grid = fine.grid[,1:3]
names(fine.grid) = c('x1', 'x2', 'x3')

fine.grid$rad = predict(object = mod.cutof.post$rad.cutof, newdata = fine.grid[,c('x1', 'x2', 'x3')])
fine.grid$pol = predict(object = mod.cutof.post$pol.cutof, newdata = fine.grid[,c('x1', 'x2', 'x3')])
fine.grid$lin = predict(object = mod.cutof.post$lin.cutof, newdata = fine.grid[,c('x1', 'x2', 'x3')])
fine.grid$sig = predict(object = mod.cutof.post$sig.cutof, newdata = fine.grid[,c('x1', 'x2', 'x3')])

g1 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = rad)) +
  labs(subtitle = 'SVM: Radius', title = 'Threshold Cutoff', x = '', y = '') + guides(color = FALSE)
g2 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = pol)) +
  labs(subtitle = 'SVM: Cubic', x = '', y = '') + guides(color = FALSE)
g3 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = lin)) +
  labs(subtitle = 'SVM: Linear', x = '', y = '') + guides(color = FALSE)
g4 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = sig)) +
  labs(subtitle = 'SVM: Sigmoidal', x = '', y = '') + guides(color = FALSE)
((g1 + g2) / (g3 + g4))
ggplot() +
  geom_point(data.cutof, mapping = aes(x = x1, y = x2, alpha = 1-abs(x3 - 0.5), fill = as.factor(cat)), 
             color = 'black', size = 3, shape = 21) +
  labs(title = 'True Data: Threshold Cutoff', x = '', y = '', fille = 'Designation') + guides(alpha = FALSE)

fine.grid$rad = predict(object = mod.delta.post$rad.delta, newdata = fine.grid[,c('x1', 'x2', 'x3')])
fine.grid$pol = predict(object = mod.delta.post$pol.delta, newdata = fine.grid[,c('x1', 'x2', 'x3')])
fine.grid$lin = predict(object = mod.delta.post$lin.delta, newdata = fine.grid[,c('x1', 'x2', 'x3')])
fine.grid$sig = predict(object = mod.delta.post$sig.delta, newdata = fine.grid[,c('x1', 'x2', 'x3')])

g1 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = rad)) +
  labs(subtitle = 'SVM: Radius', title = 'Pareto Distance Cutoff', x = '', y = '') + guides(color = FALSE)
g2 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = pol)) +
  labs(subtitle = 'SVM: Cubic', x = '', y = '') + guides(color = FALSE)
g3 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = lin)) +
  labs(subtitle = 'SVM: Linear', x = '', y = '') + guides(color = FALSE)
g4 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = sig)) +
  labs(subtitle = 'SVM: Sigmoidal', x = '', y = '') + guides(color = FALSE)
((g1 + g2) / (g3 + g4))
ggplot() +
  geom_point(data.delta, mapping = aes(x = x1, y = x2, alpha = 1-abs(x3 - 0.5), fill = as.factor(cat)), 
             color = 'black', size = 3, shape = 21) +
  labs(title = 'True Data: Pareto Distance Cutoff', x = '', y = '', fille = 'Designation') + guides(alpha = FALSE)

fine.grid$rad = predict(object = mod.radan.post$rad.radan, newdata = fine.grid[,c('x1', 'x2', 'x3')])
fine.grid$pol = predict(object = mod.radan.post$pol.radan, newdata = fine.grid[,c('x1', 'x2', 'x3')])
fine.grid$lin = predict(object = mod.radan.post$lin.radan, newdata = fine.grid[,c('x1', 'x2', 'x3')])
fine.grid$sig = predict(object = mod.radan.post$sig.radan, newdata = fine.grid[,c('x1', 'x2', 'x3')])

g1 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = rad)) +
  labs(subtitle = 'SVM: Radius', title = 'Utopia Distance Cutoff', x = '', y = '') + guides(color = FALSE)
g2 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = pol)) +
  labs(subtitle = 'SVM: Cubic', x = '', y = '') + guides(color = FALSE)
g3 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = lin)) +
  labs(subtitle = 'SVM: Linear', x = '', y = '') + guides(color = FALSE)
g4 = ggplot() +
  geom_point(fine.grid, mapping = aes(x = x1, y = x2, color = sig)) +
  labs(subtitle = 'SVM: Sigmoidal', x = '', y = '') + guides(color = FALSE)
((g1 + g2) / (g3 + g4))
ggplot() +
  geom_point(data.radan, mapping = aes(x = x1, y = x2, alpha = 1-abs(x3 - 0.5), fill = as.factor(cat)), 
             color = 'black', size = 3, shape = 21) +
  labs(title = 'True Data: Utopia Distance Cutoff', x = '', y = '', fille = 'Designation') + guides(alpha = FALSE)

```

The SVM all predict effectively no points will satisfy the criteria. The sole reason the error is so low is because the region of interest is incredibly small compared. This also explains why all SVM model types have the same error rate: they all make effectively the same prediction.

----------



```{r SVM: Distance}
GPar.all = read.csv(file = 'GPar_all_start.csv')
data.delta = read.csv('GPar_Accept_Delta1.csv')

# Define acceptance
GPar.all$cat = 0; data.delta$cat = 0; fine.grid$cat = 0
GPar.all$cat[GPar.all$dist <= 1] = 1
data.delta$cat[data.delta$dist <= 1] = 1
fine.grid$cat[fine.grid$dist <= 1] = 1

mod.pre = SVM.mod.all(input.data = GPar.all)

SVM.input(fine.input = fine.grid[,c('x1', 'x2', 'cat')], 
          mod.rad = mod.pre$rad, mod.lin = mod.pre$lin, 
          mod.pol = mod.pre$pol, mod.sig = mod.pre$sig,
          tit = 'Pareto Distance, Pre-Refinement')

mod.post = SVM.mod.all(input.data = data.delta)

SVM.input(fine.input = fine.grid[,c('x1', 'x2', 'cat')], 
          mod.rad = mod.post$rad, mod.lin = mod.post$lin, 
          mod.pol = mod.post$pol, mod.sig = mod.post$sig,
          tit = 'Pareto Distance, Post-Refinement')

err.pre = SVM.err(fine.input = fine.grid, mod.list = mod.pre)
err.pre$source = '0pre'; err.pre$criteria = 'Pareto Distance'
err.post = SVM.err(fine.input = fine.grid, mod.list = mod.post)
err.post$source = '1post'; err.post$criteria = 'Pareto Distance'

err.svm.dist = rbind(err.pre, err.post)
err.svm.dist

ggplot(err.svm.dist) +
  geom_col(mapping = aes(x = source, y = rate, fill = source)) +
  facet_wrap(~method, nrow = 1)
rm(err.pre, err.post)

```
Graphically, the selection of the kernel form has a large impact on the quality of the result. 
The polynomial and radial kernels appear to roughly match the shape of the noramlized distance = 1 criterion; 
the linear and sigmoidal kernels do not appear to match anything. 
Further tuning of the polynomial degree or coefficient could improve the results, but without a training-testing set delineation, there is no way to validate the results.

Closer inspection of the SVM model with a fine-resolution grid shows the radial function produces an irregularly shaped result that is difficult to describe with means and standard deviations. 
The polynomial kernel model does not have this issue at the cost of accuracy.
The black-box function is not clearly invertible, making describing the boundary of what is accepted/rejected difficult.
Using a Monte Carlo method to marginalize to find the probability given only a single input variable first.

```{r SVM: Distance marginals}

```


```{r}
x.rng = seq(from = 0, to = 5, length.out = 50)
svm.margin = data.frame()
nsamp = 2000
for(x in x.rng){
  # x1 marginal
  temp.frame = data.frame(x1 = x, x2 = runif(n = nsamp, min = 0, max = 5))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 0, prob = sum(res)/length(res), method = 'pol'))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 0, prob = sum(res)/length(res), method = 'rad'))
  # x1 marginal
  temp.frame = data.frame(x2 = x, x1 = runif(n = nsamp, min = 0, max = 5))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 0, prob = sum(res)/length(res), method = 'pol'))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 0, prob = sum(res)/length(res), method = 'rad'))
}

ggplot(svm.margin) +
  geom_path(mapping = aes(x = x, y = prob, color = method)) +
  facet_wrap(~var, nrow = 2) + theme_classic() + theme(legend.position = c(0.9, 0.85)) +
  labs(x = 'Input Value', y = 'Conditional Probability', color = 'SVM Kernel') +
  scale_color_discrete(labels = c('pol' = 'Polynomial', 'rad' = 'Radial')) +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(limits = c(0, 1))

p.cut.x1.pol = 0.5*max(filter(svm.margin, var == 'x1', method == 'pol')$prob)
p.cut.x2.pol = 0.5*max(filter(svm.margin, var == 'x2', method == 'pol')$prob)
x1.pol.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x1', method == 'pol')$x)
x2.pol.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x2', method == 'pol')$x)
p.cut.x1.rad = 0.5*max(filter(svm.margin, var == 'x1', method == 'rad')$prob)
p.cut.x2.rad = 0.5*max(filter(svm.margin, var == 'x2', method == 'rad')$prob)
x1.rad.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x1', method == 'rad')$x)
x2.rad.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x2', method == 'rad')$x)

for(x in x.rng){
  # x1 marginal
  temp.frame = data.frame(x1 = x, x2 = runif(n = nsamp, min = min(x2.pol.rng), max = max(x2.pol.rng)))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 1, prob = sum(res)/length(res), method = 'pol'))
  temp.frame = data.frame(x1 = x, x2 = runif(n = nsamp, min = min(x2.rad.rng), max = max(x2.rad.rng)))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 1, prob = sum(res)/length(res), method = 'rad'))
  # x1 marginal
  temp.frame = data.frame(x2 = x, x1 = runif(n = nsamp, min = min(x1.pol.rng), max = max(x1.pol.rng)))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 1, prob = sum(res)/length(res), method = 'pol'))
  temp.frame = data.frame(x2 = x, x1 = runif(n = nsamp, min = min(x1.rad.rng), max = max(x1.rad.rng)))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 1, prob = sum(res)/length(res), method = 'rad'))
}

ggplot(svm.margin) +
  geom_path(mapping = aes(x = x, y = prob, color = method, linetype = as.factor(ncond))) +
  facet_wrap(~var, nrow = 2) + theme_classic() + 
  labs(x = 'Input Value', y = 'Conditional Probability', color = 'SVM Kernel', linetype = '# Conditions') +
  scale_color_discrete(labels = c('pol' = 'Polynomial', 'rad' = 'Radial')) +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(limits = c(0, 1))

write.csv(svm.margin, 'Margin_SVM_dist.csv')

```

The single-variable marginals roughly match expectation for x1, although the probabilities estimated by SVM are higher than those estimated by the GP. This is expected since the GP automatically accounts for model uncertainty, but the SVM Monte Carlo does not account for the inaccuracy of the model.
For x2, the marginal for the polynomial kernel does not capture the multimodal nature of the curve, consistent with the shape of the fine-resolution depiction of the model. The radial kernel captures this feature, but smooths it out compared to the GP estimate.
The partial conditional, where the secondary variable is bounded to its "optimal" region shows obvious improvement in the probability, but not in the the shape of the curves.

Repeating for the f1 and f2 cutoffs.

```{r SVM: Threshold}
GPar.all = read.csv(file = 'GPar_all_start.csv')
data.cutof = read.csv('GPar_Accept_Threshold.csv')

# Define acceptance
GPar.all$cat = 0; data.cutof$cat = 0; fine.grid$cat = 0
GPar.all$cat[GPar.all$f1.norm <= 1 & GPar.all$f2.norm <= 1] = 1
data.cutof$cat[data.cutof$f1.norm <= 1 & data.cutof$f2.norm <= 1] = 1
fine.grid$cat[fine.grid$f1.norm <= 1 & fine.grid$f2.norm <= 1] = 1

mod.pre = SVM.mod.all(input.data = GPar.all)

SVM.input(fine.input = fine.grid[,c('x1', 'x2', 'cat')], 
          mod.rad = mod.pre$rad, mod.lin = mod.pre$lin, 
          mod.pol = mod.pre$pol, mod.sig = mod.pre$sig,
          tit = 'Pareto Distance, Pre-Refinement')

mod.post = SVM.mod.all(input.data = data.delta)

SVM.input(fine.input = fine.grid[,c('x1', 'x2', 'cat')], 
          mod.rad = mod.post$rad, mod.lin = mod.post$lin, 
          mod.pol = mod.post$pol, mod.sig = mod.post$sig,
          tit = 'Pareto Distance, Post-Refinement')

err.pre = SVM.err(fine.input = fine.grid, mod.list = mod.pre)
err.pre$source = '0pre'; err.pre$criteria = 'Objective Cutoff'
err.post = SVM.err(fine.input = fine.grid, mod.list = mod.post)
err.post$source = '1post'; err.post$criteria = 'Objective Cutoff'

err.svm.threshold = rbind(err.pre, err.post)
err.svm.threshold

ggplot(err.svm.threshold) +
  geom_col(mapping = aes(x = source, y = rate, fill = source)) +
  facet_wrap(~method, nrow = 1)
rm(err.pre, err.post)

```

```{r}
x.rng = seq(from = 0, to = 5, length.out = 50)
svm.margin = data.frame()
nsamp = 2000
for(x in x.rng){
  # x1 marginal
  temp.frame = data.frame(x1 = x, x2 = runif(n = nsamp, min = 0, max = 5))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 0, prob = sum(res)/length(res), method = 'pol'))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 0, prob = sum(res)/length(res), method = 'rad'))
  # x1 marginal
  temp.frame = data.frame(x2 = x, x1 = runif(n = nsamp, min = 0, max = 5))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 0, prob = sum(res)/length(res), method = 'pol'))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 0, prob = sum(res)/length(res), method = 'rad'))
}

ggplot(svm.margin) +
  geom_path(mapping = aes(x = x, y = prob, color = method)) +
  facet_wrap(~var, nrow = 2) + theme_classic() + theme(legend.position = c(0.9, 0.85)) +
  labs(x = 'Input Value', y = 'Conditional Probability', color = 'SVM Kernel') +
  scale_color_discrete(labels = c('pol' = 'Polynomial', 'rad' = 'Radial')) +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(limits = c(0, 1))

p.cut.x1.pol = 0.5*max(filter(svm.margin, var == 'x1', method == 'pol')$prob)
p.cut.x2.pol = 0.5*max(filter(svm.margin, var == 'x2', method == 'pol')$prob)
x1.pol.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x1', method == 'pol')$x)
x2.pol.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x2', method == 'pol')$x)
p.cut.x1.rad = 0.5*max(filter(svm.margin, var == 'x1', method == 'rad')$prob)
p.cut.x2.rad = 0.5*max(filter(svm.margin, var == 'x2', method == 'rad')$prob)
x1.rad.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x1', method == 'rad')$x)
x2.rad.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x2', method == 'rad')$x)

for(x in x.rng){
  # x1 marginal
  temp.frame = data.frame(x1 = x, x2 = runif(n = nsamp, min = min(x2.pol.rng), max = max(x2.pol.rng)))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 1, prob = sum(res)/length(res), method = 'pol'))
  temp.frame = data.frame(x1 = x, x2 = runif(n = nsamp, min = min(x2.rad.rng), max = max(x2.rad.rng)))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 1, prob = sum(res)/length(res), method = 'rad'))
  # x1 marginal
  temp.frame = data.frame(x2 = x, x1 = runif(n = nsamp, min = min(x1.pol.rng), max = max(x1.pol.rng)))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 1, prob = sum(res)/length(res), method = 'pol'))
  temp.frame = data.frame(x2 = x, x1 = runif(n = nsamp, min = min(x1.rad.rng), max = max(x1.rad.rng)))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 1, prob = sum(res)/length(res), method = 'rad'))
}

ggplot(svm.margin) +
  geom_path(mapping = aes(x = x, y = prob, color = method, linetype = as.factor(ncond))) +
  facet_wrap(~var, nrow = 2) + theme_classic() + 
  labs(x = 'Input Value', y = 'Conditional Probability', color = 'SVM Kernel', linetype = '# Conditions') +
  scale_color_discrete(labels = c('pol' = 'Polynomial', 'rad' = 'Radial')) +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(limits = c(0, 1))

write.csv(svm.margin, 'Margin_SVM_threshold.csv')

```

Graphically, the results are the same as the distance cutoff: the polynomial and radial kernels perform best, with the radial kernel over-complicated and the polynomial kernel oversimplified compared to the true boundary.

Repeat for radius-angle cutoff
```{r SVM: Radius and Priority}
GPar.all = read.csv(file = 'GPar_all_start.csv')
data.radan = read.csv('GPar_Accept_Radius.csv')

# Define acceptance
GPar.all$cat = 0; data.radan$cat = 0; fine.grid$cat = 0
GPar.all$cat[sqrt(GPar.all$f1.norm^2 + GPar.all$f2.norm^2) <= 1 & GPar.all$theta > 20] = 1
data.radan$cat[sqrt(data.radan$f1.norm^2 + data.radan$f2.norm^2) <= 1 & data.radan$theta > 20] = 1
fine.grid$cat[sqrt(fine.grid$f1.norm^2 + fine.grid$f2.norm^2) <= 1 & fine.grid$ang > 20] = 1

mod.pre = SVM.mod.all(input.data = GPar.all)

SVM.input(fine.input = fine.grid[,c('x1', 'x2', 'cat')], 
          mod.rad = mod.pre$rad, mod.lin = mod.pre$lin, 
          mod.pol = mod.pre$pol, mod.sig = mod.pre$sig,
          tit = 'Utopia Distance and Priority, Pre-Refinement')

mod.post = SVM.mod.all(input.data = data.delta)

SVM.input(fine.input = fine.grid[,c('x1', 'x2', 'cat')], 
          mod.rad = mod.post$rad, mod.lin = mod.post$lin, 
          mod.pol = mod.post$pol, mod.sig = mod.post$sig,
          tit = 'Utopia Distance and Priority, Post-Refinement')

err.pre = SVM.err(fine.input = fine.grid, mod.list = mod.pre)
err.pre$source = '0pre'; err.pre$criteria = 'Utopia Distance + Priority'
err.post = SVM.err(fine.input = fine.grid, mod.list = mod.post)
err.post$source = '1post'; err.post$criteria = 'Utopia Distance + Priority'

err.svm.radan = rbind(err.pre, err.post)
err.svm.radan

ggplot(err.svm.radan) +
  geom_col(mapping = aes(x = source, y = rate, fill = source)) +
  facet_wrap(~method, nrow = 1)
rm(err.pre, err.post)

```

```{r}
x.rng = seq(from = 0, to = 5, length.out = 50)
svm.margin = data.frame()
nsamp = 2000
for(x in x.rng){
  # x1 marginal
  temp.frame = data.frame(x1 = x, x2 = runif(n = nsamp, min = 0, max = 5))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 0, prob = sum(res)/length(res), method = 'pol'))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 0, prob = sum(res)/length(res), method = 'rad'))
  # x1 marginal
  temp.frame = data.frame(x2 = x, x1 = runif(n = nsamp, min = 0, max = 5))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 0, prob = sum(res)/length(res), method = 'pol'))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 0, prob = sum(res)/length(res), method = 'rad'))
}

ggplot(svm.margin) +
  geom_path(mapping = aes(x = x, y = prob, color = method)) +
  facet_wrap(~var, nrow = 2) + theme_classic() + theme(legend.position = c(0.9, 0.85)) +
  labs(x = 'Input Value', y = 'Conditional Probability', color = 'SVM Kernel') +
  scale_color_discrete(labels = c('pol' = 'Polynomial', 'rad' = 'Radial')) +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(limits = c(0, 1))

p.cut.x1.pol = 0.5*max(filter(svm.margin, var == 'x1', method == 'pol')$prob)
p.cut.x2.pol = 0.5*max(filter(svm.margin, var == 'x2', method == 'pol')$prob)
x1.pol.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x1', method == 'pol')$x)
x2.pol.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x2', method == 'pol')$x)
p.cut.x1.rad = 0.5*max(filter(svm.margin, var == 'x1', method == 'rad')$prob)
p.cut.x2.rad = 0.5*max(filter(svm.margin, var == 'x2', method == 'rad')$prob)
x1.rad.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x1', method == 'rad')$x)
x2.rad.rng = range(filter(svm.margin, prob > p.cut.x1.pol, var == 'x2', method == 'rad')$x)

for(x in x.rng){
  # x1 marginal
  temp.frame = data.frame(x1 = x, x2 = runif(n = nsamp, min = min(x2.pol.rng), max = max(x2.pol.rng)))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 1, prob = sum(res)/length(res), method = 'pol'))
  temp.frame = data.frame(x1 = x, x2 = runif(n = nsamp, min = min(x2.rad.rng), max = max(x2.rad.rng)))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x1', ncond = 1, prob = sum(res)/length(res), method = 'rad'))
  # x1 marginal
  temp.frame = data.frame(x2 = x, x1 = runif(n = nsamp, min = min(x1.pol.rng), max = max(x1.pol.rng)))
  res = as.numeric(predict(object = mod.post$pol, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 1, prob = sum(res)/length(res), method = 'pol'))
  temp.frame = data.frame(x2 = x, x1 = runif(n = nsamp, min = min(x1.rad.rng), max = max(x1.rad.rng)))
  res = as.numeric(predict(object = mod.post$rad, newdata = temp.frame))-1
  svm.margin = rbind(svm.margin, data.frame(x = x, var = 'x2', ncond = 1, prob = sum(res)/length(res), method = 'rad'))
}

ggplot(svm.margin) +
  geom_path(mapping = aes(x = x, y = prob, color = method, linetype = as.factor(ncond))) +
  facet_wrap(~var, nrow = 2) + theme_classic() + 
  labs(x = 'Input Value', y = 'Conditional Probability', color = 'SVM Kernel', linetype = '# Conditions') +
  scale_color_discrete(labels = c('pol' = 'Polynomial', 'rad' = 'Radial')) +
  scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(limits = c(0, 1))

write.csv(svm.margin, 'Margin_SVM_radius.csv')


```

Compared to the training data, the results work very well for the radial kernel only. However, when compared to the full system evaluation with a fine resolution grid, it is evident that there is some overfitting. This leads to unusual curves for the conditional probabilities. This generally indicates that more complicated selection criteria, particularly those that lead to discontinuous regions of acceptance, are not likely to behave well with the SVM.

# Existing Method: Gaussian Mixtures

Since the GM models are unsupervised, there cannot be control for what the selection criteria are. A superficial analysis will be conducted to check what the ML algorithm is converging to, but the results will be interpreted solely in terms of descriptive statistics.

For the purposes of analysis, three models will be tested based on the input to the ML algorithm:
* (x1, x2, f1, f2): the full set of inputs and outputs - since it has the most data, this will likely be the most robust
* (x1, x2): negative control of just the inputs - it should group the points based on the sampling densities
* (f1, f2): outputs only - this should have the best distinction between good and bad performing groups

Up to 12 categories will be allowed, and any type of Gaussian models will be accepted. This will lead to longer fitting time, but should help with accuracy.

```{r}
GPar.all = read.csv(file = 'GPar_all_start.csv')

# names(GPar.all)
max.cat = 12
cluster.all = Mclust(data = GPar.all[,c('x1', 'x2', 'f1', 'f2')], G = 2:max.cat)
cluster.in = Mclust(data = GPar.all[,c('x1', 'x2')], G = 2:max.cat)
cluster.out = Mclust(data = GPar.all[,c('f1', 'f2')], G = 2:max.cat)

```

```{r}
# summary(cluster, parameters = TRUE)

GPar.all$typ.all = cluster.all$classification
GPar.all$typ.in = cluster.in$classification
GPar.all$typ.out = cluster.out$classification

ggplot() +
  # Boundaries: +/- some separation from 0.5
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = dist, color = 'delta'), breaks = c(1)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = ff1, color = 'cutof'), breaks = c(0.5)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = rad, color = 'rad'), breaks = c(1)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = ang, color = 'ang'), breaks = c(50)) +
  # Pareto frontier
  geom_smooth(data = GPar.front, mapping = aes(x = x1, y = x2, color = 'Pareto'), 
              level = 0.95, formula = (y~x), method = 'loess') + 
  # Clustering
  geom_point(data = GPar.all, mapping = aes(x = x1, y = x2, fill = as.factor(typ.all)), size = 2.5, shape = 21) +

  labs(x = expression('x'[1]), y = expression('x'[2]), 
       color = 'Acceptance Criteria', fill = 'Group', 
       subtitle = '(x1, x2, f1, f2)') +
  scale_color_manual(values = c('delta' = '#1b9e77', 'cutof' = '#d95f02', 
                                'rad' = '#7570b3', 'ang' = '#e7298a', 
                                'Pareto' = 'black'),
                     labels = c('delta' = expression(delta*' < 1'), 
                                'cutof' = expression('F'[1]^'*'*'< 1, F'[2]^'*'*'< 1'), 
                                'rad' = expression('r < 1'),
                                'ang' = expression('F'[1]*'and F'[2]*' Balance'),
                                'Pareto' = expression('Pareto Front')),
                     breaks = c('delta', 'cutof', 'rad', 'ang', 'Pareto')) +
  theme_classic() + #theme(legend.position = c(0.85, 0.75)) + 
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 5)) +
  guides(colour = guide_legend(override.aes = list(fill = alpha('white', 1))))

ggplot() +
  # Boundaries: +/- some separation from 0.5
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = dist, color = 'delta'), breaks = c(1)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = ff1, color = 'cutof'), breaks = c(0.5)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = rad, color = 'rad'), breaks = c(1)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = ang, color = 'ang'), breaks = c(50)) +
  # Pareto frontier
  geom_smooth(data = GPar.front, mapping = aes(x = x1, y = x2, color = 'Pareto'), 
              level = 0.95, formula = (y~x), method = 'loess') + 
  # Clustering
  geom_point(data = GPar.all, mapping = aes(x = x1, y = x2, fill = as.factor(typ.in)), size = 2.5, shape = 21) +

  labs(x = expression('x'[1]), y = expression('x'[2]), 
       color = 'Acceptance Criteria', fill = 'Group', 
       subtitle = '(x1, x2)') +
  scale_color_manual(values = c('delta' = '#1b9e77', 'cutof' = '#d95f02', 
                                'rad' = '#7570b3', 'ang' = '#e7298a', 
                                'Pareto' = 'black'),
                     labels = c('delta' = expression(delta*' < 1'), 
                                'cutof' = expression('F'[1]^'*'*'< 1, F'[2]^'*'*'< 1'), 
                                'rad' = expression('r < 1'),
                                'ang' = expression('F'[1]*'and F'[2]*' Balance'),
                                'Pareto' = expression('Pareto Front')),
                     breaks = c('delta', 'cutof', 'rad', 'ang', 'Pareto')) +
  theme_classic() + #theme(legend.position = c(0.85, 0.75)) + 
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 5)) +
  guides(colour = guide_legend(override.aes = list(fill = alpha('white', 1))))

ggplot() +
  # Boundaries: +/- some separation from 0.5
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = dist, color = 'delta'), breaks = c(1)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = ff1, color = 'cutof'), breaks = c(0.5)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = rad, color = 'rad'), breaks = c(1)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = ang, color = 'ang'), breaks = c(50)) +
  # Pareto frontier
  geom_smooth(data = GPar.front, mapping = aes(x = x1, y = x2, color = 'Pareto'), 
              level = 0.95, formula = (y~x), method = 'loess') + 
  # Clustering
  geom_point(data = GPar.all, mapping = aes(x = x1, y = x2, fill = as.factor(typ.out)), size = 2.5, shape = 21) +

  labs(x = expression('x'[1]), y = expression('x'[2]), 
       color = 'Acceptance Criteria', fill = 'Group', 
       subtitle = '(f1, f2)') +
  scale_color_manual(values = c('delta' = '#1b9e77', 'cutof' = '#d95f02', 
                                'rad' = '#7570b3', 'ang' = '#e7298a', 
                                'Pareto' = 'black'),
                     labels = c('delta' = expression(delta*' < 1'), 
                                'cutof' = expression('F'[1]^'*'*'< 1, F'[2]^'*'*'< 1'), 
                                'rad' = expression('r < 1'),
                                'ang' = expression('F'[1]*'and F'[2]*' Balance'),
                                'Pareto' = expression('Pareto Front')),
                     breaks = c('delta', 'cutof', 'rad', 'ang', 'Pareto')) +
  theme_classic() + #theme(legend.position = c(0.85, 0.75)) + 
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 5)) +
  guides(colour = guide_legend(override.aes = list(fill = alpha('white', 1))))

```

The complete input (x1, x2, f1, f2) overcomplicates the system, providing 8 groups. One of these groups is clearly the Pareto frontier, but it does not include any points that are of similar performance. There are points to either side of it suggesting similar performance, but how far they extend is difficult to interpret.

The negative control (x1, x2) gives the expected result of largely grouping based on sampling density. This means the highly sampled Pareto frontier and local minimum are their own groups, and the rest of the space is divided based around the boundary between the highly sampled regions.

The output-only model gives the most useful results, as it groups the Pareto frontier inside of another high-performing group, which also includes the local optimum and the space spanning to it. It roughly lines up with the Pareto distance or threshold criteria; it does not appear to prioritize the angle or utopia distance. Showing only this model at finer resolution as it is the only relevant performing model

```{r}
res = predict(object = cluster.out, newdata = fine.grid[c('f1', 'f2')])
fine.grid$cluster.out = res$classification
ggplot() +
  # Cluster results
  geom_point(data = fine.grid, mapping = aes(x = x1, y = x2, color = as.factor(cluster.out))) +
  # Boundaries: +/- some separation from 0.5
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = dist), color = 'black', breaks = c(1)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = ff1), color = 'red', breaks = c(0.5)) +

  labs(x = expression('x'[1]), y = expression('x'[2]), 
       color = 'Group', fill = 'Group', 
       subtitle = '(f1, f2)') +
  theme_classic() + #theme(legend.position = c(0.85, 0.75)) + 
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 5)) +
  guides(colour = guide_legend(override.aes = list(fill = alpha('white', 1))))

res = predict(object = cluster.all, newdata = fine.grid[c('x1', 'x2', 'f1', 'f2')])
fine.grid$cluster.all = res$classification
ggplot() +
  # Cluster results
  geom_point(data = fine.grid, mapping = aes(x = x1, y = x2, color = as.factor(cluster.all)), size = 4) +
  # Boundaries: +/- some separation from 0.5
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = dist), color = 'black', breaks = c(1)) +
  geom_contour(data = fine.grid, mapping = aes(x = x1, y = x2, z = ff1), color = 'red', breaks = c(0.5)) +

  labs(x = expression('x'[1]), y = expression('x'[2]), 
       color = 'Group', fill = 'Group', 
       subtitle = '(x1, x2, f1, f2)') +
  theme_classic() + #theme(legend.position = c(0.85, 0.75)) + 
  scale_x_continuous(expand = c(0, 0), limits = c(0, 5)) + scale_y_continuous(expand = c(0, 0), limits = c(0, 5)) +
  guides(colour = guide_legend(override.aes = list(fill = alpha('white', 1))))

ggplot() +
  # Cluster results
  geom_point(data = filter(fine.grid, f2 < 50, f1 < 200), mapping = aes(x = f1, y = f2, color = as.factor(cluster.all)), size = 2) +
  labs(x = expression('f'[1]), y = expression('f'[2]), 
       color = 'Group', fill = 'Group', 
       subtitle = '(x1, x2, f1, f2)') +
  theme_classic() +
  guides(colour = guide_legend(override.aes = list(fill = alpha('white', 1))))

```

The (f1, f2) model appears to give a cluster that is somewhere between a threshold cutoff and the Pareto distance cutoff. 
In contrast, the behavior of the (x1, x2, f1, f2) model provides many more groups, including splitting the Pareto front into about three different categories with no obvious analog to why the boundaries are where they are. 
It appears to roughly fit the same boundaries of Pareto distance or threshold cutoffs, but not very well. 
A rough approximation is that groups (5, 6) are the Pareto front, groups (2, 3, 7) make up the region close to the Pareto front, and (1, 4, 8) are the region far from the front.

The model for (f1, f2) is going to give the same conditional probabilities as the Pareto distance or threshold acceptance criteria based on this similarity in the shape of the boundary. 
The interesting result to interpret is the (x1, x2, f1, f2), particularly when marginalizing to (x1, x2). 
Assuming that calculating (f1, f2) is expensive, the best approximation is that found from the GP models used to find the Pareto front itself. 
These will give (f1, f2) as a bivariate Gaussian distribution, which can be sampled from to estimate the likelihood that it falls into the Pareto front, the region close to it, or the region far from it.
This is achievable with a sequential Monte Carlo: given x1, sample x2 from the range, find the distribution of (f1, f2), sample (f1, f2), and solve the classification into the three groups.

```{r}
f1.mod = fill.sample.mod(GPar.data = GPar.all, input.name = c('x1', 'x2'), output.name = 'f1')
f2.mod = fill.sample.mod(GPar.data = GPar.all, input.name = c('x1', 'x2'), output.name = 'f2')

x.rng = seq(from = 0, to = 5, length.out = 50)
nsamp.x = 100; nsamp.f = 100
gm.margin = data.frame()
for(x in x.rng){
  # x1
  # Sample x2
  inframe = data.frame(x1 = x, x2 = runif(n = nsamp.x, min = 0, max = 5))
  classes = c()
  for(n in 1:nrow(inframe)){
    # Estimate distribution for f1, f2
    f1.est = predict(object = f1.mod, newdata = inframe, type = 'UK')
    f2.est = predict(object = f2.mod, newdata = inframe, type = 'UK')
    test.frame = data.frame(x1 = inframe$x1, x2 = inframe$x2,
                            f1 = rnorm(n = nsamp.f, mean = f1.est$mean, sd = f1.est$sd),
                            f2 = rnorm(n = nsamp.f, mean = f2.est$mean, sd = f2.est$sd))
    res = predict(object = cluster.all, newdata = test.frame)
    classes = c(classes, res$classification)
  }
  classes = data.frame(group = classes)
  gm.margin = rbind(gm.margin, data.frame(x = x, var = 'x1', 
                         p.pare = nrow(filter(classes, group == 5 | group == 6))/(nsamp.f*nsamp.x), 
                         p.near = nrow(filter(classes, group == 2 | group == 3 | group == 7))/(nsamp.f*nsamp.x), 
                         p.dist = nrow(filter(classes, group == 1 | group == 4 | group == 8))/(nsamp.f*nsamp.x)))
  # x2
  # Sample x2
  inframe = data.frame(x2 = x, x1 = runif(n = nsamp.x, min = 0, max = 5))
  classes = c()
  for(n in 1:nrow(inframe)){
    # Estimate distribution for f1, f2
    f1.est = predict(object = f1.mod, newdata = inframe, type = 'UK')
    f2.est = predict(object = f2.mod, newdata = inframe, type = 'UK')
    test.frame = data.frame(x1 = inframe$x1, x2 = inframe$x2,
                            f1 = rnorm(n = nsamp.f, mean = f1.est$mean, sd = f1.est$sd),
                            f2 = rnorm(n = nsamp.f, mean = f2.est$mean, sd = f2.est$sd))
    res = predict(object = cluster.all, newdata = test.frame)
    classes = c(classes, res$classification)
  }
  classes = data.frame(group = classes)
  gm.margin = rbind(gm.margin, data.frame(x = x, var = 'x2', 
                         p.pare = nrow(filter(classes, group == 5 | group == 6))/(nsamp.f*nsamp.x), 
                         p.near = nrow(filter(classes, group == 2 | group == 3 | group == 7))/(nsamp.f*nsamp.x), 
                         p.dist = nrow(filter(classes, group == 1 | group == 4 | group == 8))/(nsamp.f*nsamp.x)))
}

write.csv(gm.margin, 'Margin_GM.csv')
```

```{r}
gm.margin = read.csv('Margin_GM.csv')
gm.margin = data.frame(x = rep(gm.margin$x, 3),
                       var = rep(gm.margin$var, 3),
                       prob = c(gm.margin$p.pare, gm.margin$p.near, gm.margin$p.dist),
                       typ = c(rep('Pareto', nrow(gm.margin)), 
                               rep('Near-Pareto', nrow(gm.margin)), 
                               rep('Suboptimal', nrow(gm.margin))))
ggplot(gm.margin) +
  geom_path(mapping = aes(x = x, y = prob, color = typ)) +
  facet_wrap(~var, nrow = 2) +
  scale_color_brewer(palette = 'Dark2') + 
  labs(x = 'Input Value', y = 'Conditional Probability', color = 'Region')

gm.margin = read.csv('Margin_GM.csv')
gm.margin = data.frame(x = rep(gm.margin$x),
                       var = rep(gm.margin$var),
                       prob = gm.margin$p.pare + gm.margin$p.near,
                       typ = 'Optimal')
ggplot(gm.margin) +
  geom_path(mapping = aes(x = x, y = prob, color = typ)) +
  facet_wrap(~var, nrow = 2) +
  scale_color_brewer(palette = 'Dark2') + 
  labs(x = 'Input Value', y = 'Conditional Probability', color = 'Region')

```

The estimated probability of being optimal (Pareto front group or the near-Pareto group) is similar to that calculated through the other methods for the Pareto distance or threshold criteria. However, because of the numerous variables required to generate the model, a larger and more complicated sampling procedure is necessary for accurate estimates.


# Comaprison of method accuracies

The error rate can only be compared between the the GP and SVM methods because the accuracy is dependent on the selection criteria that were set.

```{r Error comparison}
dat = rbind(error.rate, err.svm.dist, err.svm.radan, err.svm.threshold)
dat$criteria[dat$criteria == 'Utopia Distance + Priority'] = 'Distance + Priority'

ggplot(dat) +
  geom_col(mapping = aes(x = source, fill = source, y = rate)) +
  geom_errorbar(mapping = aes(x = source, y = rate, ymax = rate+err, ymin = rate-err), width = 0.5) +
  facet_grid(criteria~method, switch = 'x') +
  scale_x_discrete(breaks = c()) + scale_y_continuous(expand = c(0.01, 0)) +
  scale_fill_discrete(labels = c('0pre' = 'Before', '1post' = 'After'), breaks = c('0pre', '1post')) +
  labs(x = '', y = 'Error Probability', fill = 'Refined')
ggplot(filter(dat, method != 'SVM-sig')) +
  geom_col(mapping = aes(x = source, fill = source, y = rate)) +
  geom_errorbar(mapping = aes(x = source, y = rate, ymax = rate+err, ymin = rate-err), width = 0.5) +
  facet_grid(criteria~method, switch = 'x') +
  scale_x_discrete(breaks = c()) + scale_y_continuous(expand = c(0.01, 0)) +
  scale_fill_discrete(labels = c('0pre' = 'Before', '1post' = 'After'), breaks = c('0pre', '1post')) +
  labs(x = '', y = 'Error Probability', fill = 'Refined')

rm(dat)

```

The iterative refinement process does not help the accuracy of the SVM models; in many cases, the additional training data leads to worse fitting. In general, the GP method for determining whether the point meets the selection criteria is more accurate, particularly after refinement with additional training data. The models could become more comparable with further tuning of free variables of the kernel functions (eg. changing the power of the polynomial kernel), but for systems where calculating the exact value is time-consuming, obtaining training-testing data to tune that variable may be difficult.

A qualitative comparison can be made among the methods' probability outputs, as well as the true marginal estimate.

```{r}

```


# Overall:
* The unsupervised ML model (Gaussian mixture) can only tend towards the criteria of having output values similar to that of the Pareto front. However, in order to obtain the model, all of the inputs and outputs are used, meaning to solve the single-variable probabilities, one must perform a time-consuming nested sampling procedure.
* The supervised ML model (Support Vector Machines) are flexible to selection criteria because those are part of the user input into generating the model. It is very sensitive to the kernel function that was selected, with the radial and polynomial forms working best for this specific case. When compared to the actual function, these good-fitting kernels appeared to be over-fit to the data and cannot capture the full dynamics of the space. In practice, separate training and testing sets should be used, which may be difficult for more complex objective functions due to more function evaluations. 
* The GP method requires iterative sampling, and therefore requires more time to compute initially. However, it accounts for the uncertainty in the model explicitly, whereas the SVM methods rely purely on frequentist sampling. This means the single-variable probabilities from the GP model estimate are generally lower than those estimated from the SVM.
* More complicated conditions, such as only accepting points that prioritize one objective over the other by a certain margin, are difficult for both supervised learning methods to estimate, but the results from the SVM appear to be worse compared to the actual boundaries.
* The SVM methods give single-variable probabilities that are 

